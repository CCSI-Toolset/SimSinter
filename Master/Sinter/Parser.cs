// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace sinter.PSE
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseSectionKeywords(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SectionKeywords), "SectionKeywords");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PARAMETER, TokenType.VARIABLE, TokenType.SET, TokenType.ASSIGN, TokenType.INITIAL, TokenType.SELECTOR, TokenType.INITIALSELECTOR);
            switch (tok.Type)
            {
                case TokenType.PARAMETER:
                    tok = scanner.Scan(TokenType.PARAMETER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PARAMETER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARAMETER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.VARIABLE:
                    tok = scanner.Scan(TokenType.VARIABLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.VARIABLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VARIABLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.SET:
                    tok = scanner.Scan(TokenType.SET);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SET) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SET.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ASSIGN:
                    tok = scanner.Scan(TokenType.ASSIGN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ASSIGN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGN.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.INITIAL:
                    tok = scanner.Scan(TokenType.INITIAL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INITIAL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INITIAL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.SELECTOR:
                    tok = scanner.Scan(TokenType.SELECTOR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SELECTOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SELECTOR.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.INITIALSELECTOR:
                    tok = scanner.Scan(TokenType.INITIALSELECTOR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INITIALSELECTOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INITIALSELECTOR.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected PARAMETER, VARIABLE, SET, ASSIGN, INITIAL, SELECTOR, or INITIALSELECTOR.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseUserType(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.UserType), "UserType");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTypeName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TypeName), "TypeName");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.REAL, TokenType.INTEGER, TokenType.BOOLEAN, TokenType.FOREIGN_OBJECT, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.REAL:
                    tok = scanner.Scan(TokenType.REAL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.REAL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REAL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.BOOLEAN:
                    tok = scanner.Scan(TokenType.BOOLEAN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOLEAN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLEAN.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.FOREIGN_OBJECT:
                    tok = scanner.Scan(TokenType.FOREIGN_OBJECT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FOREIGN_OBJECT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOREIGN_OBJECT.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                    ParseUserType(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected REAL, INTEGER, BOOLEAN, FOREIGN_OBJECT, or IDENTIFIER.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSelectorDef(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SelectorDef), "SelectorDef");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.SELECTORSTRING);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SELECTORSTRING) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SELECTORSTRING.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.SELECTORSTRING);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SELECTORSTRING) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SELECTORSTRING.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArrayDef(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ArrayDef), "ArrayDef");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ARRAY);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ARRAY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAY.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                return;
            }

            
            ParseAddExpr(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseAddExpr(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.OF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OF.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.REAL, TokenType.INTEGER, TokenType.BOOLEAN, TokenType.FOREIGN_OBJECT, TokenType.IDENTIFIER, TokenType.LPAREN);
            switch (tok.Type)
            {
                case TokenType.REAL:
                case TokenType.INTEGER:
                case TokenType.BOOLEAN:
                case TokenType.FOREIGN_OBJECT:
                case TokenType.IDENTIFIER:
                    ParseTypeName(node);
                    break;
                case TokenType.LPAREN:
                    ParseSelectorDef(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected REAL, INTEGER, BOOLEAN, FOREIGN_OBJECT, IDENTIFIER, or LPAREN.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseScalarDef(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ScalarDef), "ScalarDef");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.REAL, TokenType.INTEGER, TokenType.BOOLEAN, TokenType.FOREIGN_OBJECT, TokenType.IDENTIFIER, TokenType.LPAREN);
            switch (tok.Type)
            {
                case TokenType.REAL:
                case TokenType.INTEGER:
                case TokenType.BOOLEAN:
                case TokenType.FOREIGN_OBJECT:
                case TokenType.IDENTIFIER:
                    ParseTypeName(node);
                    break;
                case TokenType.LPAREN:
                    ParseSelectorDef(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected REAL, INTEGER, BOOLEAN, FOREIGN_OBJECT, IDENTIFIER, or LPAREN.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariableDef(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariableDef), "VariableDef");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.AS);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.AS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AS.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.ARRAY, TokenType.REAL, TokenType.INTEGER, TokenType.BOOLEAN, TokenType.FOREIGN_OBJECT, TokenType.IDENTIFIER, TokenType.LPAREN);
            switch (tok.Type)
            {
                case TokenType.ARRAY:
                    ParseArrayDef(node);
                    break;
                case TokenType.REAL:
                case TokenType.INTEGER:
                case TokenType.BOOLEAN:
                case TokenType.FOREIGN_OBJECT:
                case TokenType.IDENTIFIER:
                case TokenType.LPAREN:
                    ParseScalarDef(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ARRAY, REAL, INTEGER, BOOLEAN, FOREIGN_OBJECT, IDENTIFIER, or LPAREN.", 0x0002, tok));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.DEFAULT);
            if (tok.Type == TokenType.DEFAULT)
            {

                
                tok = scanner.Scan(TokenType.DEFAULT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DEFAULT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEFAULT.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseAddExpr(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAssignment(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Assignment), "Assignment");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ASSIGNOP);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGNOP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGNOP.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.STRING, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:

                    
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.LPAREN);
                    if (tok.Type == TokenType.LPAREN)
                    {

                        
                        tok = scanner.Scan(TokenType.LPAREN);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.LPAREN) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                            return;
                        }

                        
                        tok = scanner.LookAhead(TokenType.IDENTIFIER);
                        if (tok.Type == TokenType.IDENTIFIER)
                        {
                            tok = scanner.Scan(TokenType.IDENTIFIER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IDENTIFIER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                                return;
                            }
                        }

                        
                        tok = scanner.Scan(TokenType.RPAREN);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.RPAREN) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected NUMBER, STRING, or IDENTIFIER.", 0x0002, tok));
                    break;
            }

            
            tok = scanner.Scan(TokenType.SEMICOLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SEMICOLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArrayIndex(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ArrayIndex), "ArrayIndex");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRING, TokenType.NUMBER, TokenType.IDENTIFIER, TokenType.LPAREN);
            switch (tok.Type)
            {
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.NUMBER:
                case TokenType.IDENTIFIER:
                case TokenType.LPAREN:
                    ParseAddExpr(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected STRING, NUMBER, IDENTIFIER, or LPAREN.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArrayIndexBlock(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ArrayIndexBlock), "ArrayIndexBlock");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                return;
            }

            
            ParseArrayIndex(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseArrayIndex(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.RPAREN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RPAREN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariableRef(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariableRef), "VariableRef");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.LPAREN);
            if (tok.Type == TokenType.LPAREN)
            {
                ParseArrayIndexBlock(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseVariableExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.VariableExpr), "VariableExpr");
            parent.Nodes.Add(node);


            
            ParseVariableRef(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseVariableRef(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.LookAhead(TokenType.ASSIGNOP, TokenType.AS);
            switch (tok.Type)
            {
                case TokenType.ASSIGNOP:
                    ParseAssignment(node);
                    break;
                case TokenType.AS:
                    ParseVariableDef(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ASSIGNOP or AS.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseForBlock(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ForBlock), "ForBlock");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.ASSIGNOP);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ASSIGNOP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ASSIGNOP.ToString(), 0x1001, tok));
                return;
            }

            
            ParseAddExpr(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            ParseAddExpr(node);

            
            tok = scanner.Scan(TokenType.DO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER);
            while (tok.Type == TokenType.IDENTIFIER)
            {
                ParseVariableExpr(node);
            tok = scanner.LookAhead(TokenType.IDENTIFIER);
            }

            
            tok = scanner.Scan(TokenType.END);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.END) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.END.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseWithinBlock(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WithinBlock), "WithinBlock");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WITHIN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WITHIN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITHIN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.DO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.WITHIN, TokenType.FOR);
            while (tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.WITHIN
                || tok.Type == TokenType.FOR)
            {
                ParseExpr(node);
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.WITHIN, TokenType.FOR);
            }

            
            tok = scanner.Scan(TokenType.END);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.END) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.END.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Expr), "Expr");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.WITHIN, TokenType.FOR);
            switch (tok.Type)
            {
                case TokenType.IDENTIFIER:
                    ParseVariableExpr(node);
                    break;
                case TokenType.WITHIN:
                    ParseWithinBlock(node);
                    break;
                case TokenType.FOR:
                    ParseForBlock(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER, WITHIN, or FOR.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.WITHIN, TokenType.FOR);
            while (tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.WITHIN
                || tok.Type == TokenType.FOR)
            {
                ParseExpr(node);
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.WITHIN, TokenType.FOR);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseBadId(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.BadId), "BadId");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.LPAREN);
            if (tok.Type == TokenType.LPAREN)
            {

                
                tok = scanner.Scan(TokenType.LPAREN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.LPAREN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER);
                if (tok.Type == TokenType.IDENTIFIER
                    || tok.Type == TokenType.NUMBER)
                {
                    tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER);
                    switch (tok.Type)
                    {
                        case TokenType.IDENTIFIER:
                            ParseBadId(node);
                            break;
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NUMBER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER or NUMBER.", 0x0002, tok));
                            break;
                    }
                }

                
                tok = scanner.LookAhead(TokenType.COMMA);
                while (tok.Type == TokenType.COMMA)
                {

                    
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.NUMBER);
                    switch (tok.Type)
                    {
                        case TokenType.IDENTIFIER:
                            ParseBadId(node);
                            break;
                        case TokenType.NUMBER:
                            tok = scanner.Scan(TokenType.NUMBER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.NUMBER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER or NUMBER.", 0x0002, tok));
                            break;
                    }
                tok = scanner.LookAhead(TokenType.COMMA);
                }

                
                tok = scanner.Scan(TokenType.RPAREN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.RPAREN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAddExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AddExpr), "AddExpr");
            parent.Nodes.Add(node);


            
            ParseMultExpr(node);

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            while (tok.Type == TokenType.PLUSMINUS)
            {

                
                tok = scanner.Scan(TokenType.PLUSMINUS);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseMultExpr(node);
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMultExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MultExpr), "MultExpr");
            parent.Nodes.Add(node);


            
            ParseExponentExpr(node);

            
            tok = scanner.LookAhead(TokenType.MULTDIV);
            while (tok.Type == TokenType.MULTDIV)
            {

                
                tok = scanner.Scan(TokenType.MULTDIV);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MULTDIV) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULTDIV.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseExponentExpr(node);
            tok = scanner.LookAhead(TokenType.MULTDIV);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseExponentExpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ExponentExpr), "ExponentExpr");
            parent.Nodes.Add(node);


            
            ParseAtom(node);

            
            tok = scanner.LookAhead(TokenType.EXPONENT);
            if (tok.Type == TokenType.EXPONENT)
            {

                
                tok = scanner.Scan(TokenType.EXPONENT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EXPONENT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EXPONENT.ToString(), 0x1001, tok));
                    return;
                }

                
                ParseAtom(node);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseAtom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Atom), "Atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.NUMBER, TokenType.IDENTIFIER, TokenType.LPAREN);
            switch (tok.Type)
            {
                case TokenType.NUMBER:
                    tok = scanner.Scan(TokenType.NUMBER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMBER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMBER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                    ParseBadId(node);
                    break;
                case TokenType.LPAREN:

                    
                    tok = scanner.Scan(TokenType.LPAREN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LPAREN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LPAREN.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    ParseAddExpr(node);

                    
                    tok = scanner.Scan(TokenType.RPAREN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.RPAREN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RPAREN.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected NUMBER, IDENTIFIER, or LPAREN.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
