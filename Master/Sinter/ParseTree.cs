// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;
using System.Runtime.InteropServices;

namespace sinter.PSE
{
    #region ParseTree
    [ClassInterface(ClassInterfaceType.None)]
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }
        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.SectionKeywords:
                    Value = EvalSectionKeywords(tree, paramlist);
                    break;
                case TokenType.UserType:
                    Value = EvalUserType(tree, paramlist);
                    break;
                case TokenType.TypeName:
                    Value = EvalTypeName(tree, paramlist);
                    break;
                case TokenType.SelectorDef:
                    Value = EvalSelectorDef(tree, paramlist);
                    break;
                case TokenType.ArrayDef:
                    Value = EvalArrayDef(tree, paramlist);
                    break;
                case TokenType.ScalarDef:
                    Value = EvalScalarDef(tree, paramlist);
                    break;
                case TokenType.VariableDef:
                    Value = EvalVariableDef(tree, paramlist);
                    break;
                case TokenType.Assignment:
                    Value = EvalAssignment(tree, paramlist);
                    break;
                case TokenType.ArrayIndex:
                    Value = EvalArrayIndex(tree, paramlist);
                    break;
                case TokenType.ArrayIndexBlock:
                    Value = EvalArrayIndexBlock(tree, paramlist);
                    break;
                case TokenType.VariableRef:
                    Value = EvalVariableRef(tree, paramlist);
                    break;
                case TokenType.VariableExpr:
                    Value = EvalVariableExpr(tree, paramlist);
                    break;
                case TokenType.ForBlock:
                    Value = EvalForBlock(tree, paramlist);
                    break;
                case TokenType.WithinBlock:
                    Value = EvalWithinBlock(tree, paramlist);
                    break;
                case TokenType.Expr:
                    Value = EvalExpr(tree, paramlist);
                    break;
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.BadId:
                    Value = EvalBadId(tree, paramlist);
                    break;
                case TokenType.AddExpr:
                    Value = EvalAddExpr(tree, paramlist);
                    break;
                case TokenType.MultExpr:
                    Value = EvalMultExpr(tree, paramlist);
                    break;
                case TokenType.ExponentExpr:
                    Value = EvalExponentExpr(tree, paramlist);
                    break;
                case TokenType.Atom:
                    Value = EvalAtom(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalSectionKeywords(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalUserType(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.IDENTIFIER, 0);
        }

        protected virtual object EvalTypeName(ParseTree tree, params object[] paramlist)
        {
            Object real = this.GetValue(tree, TokenType.REAL, 0);
          if(real != null)
            return real;
        
          Object usertype = this.GetValue(tree, TokenType.UserType, 0);
          if(usertype != null)
            return usertype;
        
          Object integer = this.GetValue(tree, TokenType.INTEGER, 0);
          if(integer != null)
            return integer;
        
          Object fo = this.GetValue(tree, TokenType.FOREIGN_OBJECT, 0);
          if(fo != null)
            return fo;
          else 
            return this.GetValue(tree, TokenType.BOOLEAN, 0);
        }

        protected virtual object EvalSelectorDef(ParseTree tree, params object[] paramlist)
        {
            return "STRING";
        }

        protected virtual object EvalArrayDef(ParseTree tree, params object[] paramlist)
        {
            String type = ""; 
          String typename = (String) this.GetValue(tree, TokenType.TypeName, 0);
          if(typename != null) {
            type = typename;
          } else {
            type = (String) this.GetValue(tree, TokenType.SelectorDef, 0);
          }
          //We can only handle 1D vectors with pure numbers, so otherwise we pass ArrayLen = 0
          int arrayLen = 0;
          if(this.GetValue(tree, TokenType.AddExpr, 1) == null) {
             Object maybe_arrayLen = this.GetValue(tree, TokenType.AddExpr, 0);
              if(!(maybe_arrayLen is String)) { //If AddExpr returns a string, we can't use it, otherwise it should return some kind of number
                arrayLen = Convert.ToInt32(this.GetValue(tree, TokenType.AddExpr, 0));
              }
          } 
          sinter.PSE.variableDecleration varDef = 
        	new sinter.PSE.variableDecleration("unknown", type, arrayLen);
        
          return varDef;
        }

        protected virtual object EvalScalarDef(ParseTree tree, params object[] paramlist)
        {
            String type = ""; 
          String typename = (String) this.GetValue(tree, TokenType.TypeName, 0);
          if(typename != null) {
            type = typename;
          } else {
            type = (String) this.GetValue(tree, TokenType.SelectorDef, 0);
          }
          sinter.PSE.variableDecleration varDef = 
        	new sinter.PSE.variableDecleration("unknown", type, -1);
        
          return varDef;
        }

        protected virtual object EvalVariableDef(ParseTree tree, params object[] paramlist)
        {
            Object arrayDef = this.GetValue(tree, TokenType.ArrayDef, 0);
          sinter.PSE.variableDecleration varDef = null;
          if(arrayDef != null) {
            varDef = (sinter.PSE.variableDecleration) arrayDef;
          } else {
            varDef = (sinter.PSE.variableDecleration) this.GetValue(tree, TokenType.ScalarDef, 0);
          }
          if(this.GetValue(tree, TokenType.DEFAULT, 0) != null) {
            Object addexpr = this.GetValue(tree, TokenType.AddExpr, 0);
            if(varDef.type == sinter_Variable.sinter_IOType.si_INTEGER || varDef.type == sinter_Variable.sinter_IOType.si_INTEGER_VEC) {
              if(addexpr is String) { 
                varDef.dfault = 0;
              } else {
                varDef.dfault = Convert.ToInt32(this.GetValue(tree, TokenType.AddExpr, 0));
              }
            } else if(varDef.type == sinter_Variable.sinter_IOType.si_DOUBLE || varDef.type == sinter_Variable.sinter_IOType.si_DOUBLE_VEC) {
              if(addexpr is String) { 
                varDef.dfault = 0;
              } else {
                varDef.dfault = (double) this.GetValue(tree, TokenType.AddExpr, 0);  //AddExpr should always return a string or a double
              }
            } else if(varDef.type == sinter_Variable.sinter_IOType.si_STRING || varDef.type == sinter_Variable.sinter_IOType.si_STRING_VEC) {
              if(addexpr is String) { 
                varDef.dfault = (String) this.GetValue(tree, TokenType.AddExpr, 0);  //AddExpr should always return a string or a double
              } else {
                varDef.dfault = "";
              }      
            } 
          }
          return varDef;  //varDef = (sinter.PSE.variableDecleration) this.GetValue(tree, TokenType.ArrayDef, 0);
        }

        protected virtual object EvalAssignment(ParseTree tree, params object[] paramlist)
        {
            String value;
          String number = (String)this.GetValue(tree, TokenType.NUMBER, 0);
          String str = (String)this.GetValue(tree, TokenType.STRING, 0);
          bool isVec = false;
          if(number != null) {
            value = number;  
          } else if(str != null) {
            value = str; //Maybe we need a type afterall?
          } else {
            value = (String)this.GetValue(tree, TokenType.IDENTIFIER, 0);
            if(this.GetValue(tree, TokenType.LPAREN, 0) != null) {
        	String insideParensID = (String) this.GetValue(tree, TokenType.IDENTIFIER, 1);
               if(insideParensID != null) {
                 value += "(" + insideParensID + ")"; 
                 isVec = true;
               } else {
                 value += "()";
               }
            }
          }
        
          //OK, I don't know the path yet, that's in the one up from here, value is determined, and this should never be an array reference 
          //(by my arbitrary assumption that array references should only happen in for loops.)
          sinter.PSE.variableAssignment varAssign = new sinter.PSE.variableAssignment("", value, isVec);
           return varAssign;
        }

        protected virtual object EvalArrayIndex(ParseTree tree, params object[] paramlist)
        {
            String ss = (String) this.GetValue(tree, TokenType.STRING, 0);  //Note, a STRING is a QUOTED string.  We can't use that really.
          if(ss != null) {
            return "**invalid**";
          } else {
            Object addex = this.GetValue(tree, TokenType.AddExpr, 0);
            if(addex is String) {
              return addex;  //We can only do things with plain identifiers
            } else {
              return "**invalid**";  //Even numbers can't be used.
            }
          }
        }

        protected virtual object EvalArrayIndexBlock(ParseTree tree, params object[] paramlist)
        {
            if(this.GetValue(tree, TokenType.COMMA, 0) != null) {
            return "**invalid**";  //SimSinter doesn't support multidimensional arrays, so this is an invalid case
          }
          return this.GetValue(tree, TokenType.ArrayIndex, 0);
        }

        protected virtual object EvalVariableRef(ParseTree tree, params object[] paramlist)
        {
            String varname = (String) this.GetValue(tree, TokenType.IDENTIFIER, 0);
          String aib = (String) this.GetValue(tree, TokenType.ArrayIndexBlock, 0);
          if(aib != null) {
            return new System.Tuple<String, bool>(varname, true);
          }
          return new System.Tuple<String, bool>(varname, false);
        }

        protected virtual object EvalVariableExpr(ParseTree tree, params object[] paramlist)
        {
            List<Object> varList = new List<Object>();
          Object maybeVarDef = this.GetValue(tree, TokenType.VariableDef, 0);
          if(maybeVarDef != null) {  
            //First we have a canonical variableDecl from the first VariableDef, then we clone that for any others.  
            sinter.PSE.variableDecleration varDef = (sinter.PSE.variableDecleration) maybeVarDef;
            System.Tuple<String, bool> varref = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, 0);
            if((bool)varref.Item2 == false) {  //We can't use an array reference here, just ignore any array ref
              varDef.name = (String)varref.Item1;
              varList.Add(varDef);
            }
            int ii = 1;
            varref = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, ii);
            while(varref != null) {
              sinter.PSE.variableDecleration thisVarDef = (sinter.PSE.variableDecleration) varDef.Clone();
              if((bool)varref.Item2 == false) {  //We can't use an array reference here, just ignore any array ref
                thisVarDef.name = (String)varref.Item1;
                varList.Add(thisVarDef);
              }
              ii++;
              varref = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, ii);
            }
          } else {
            sinter.PSE.variableAssignment varAssign = (sinter.PSE.variableAssignment) this.GetValue(tree, TokenType.Assignment, 0);
            System.Tuple<String, bool> varRef = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, 0);
            varAssign.gPROMSPath = (String)varRef.Item1;
            varList.Add(varAssign);
        //    if((bool)varRef.Item2 == false) {  //We can't use an array reference here, just ignore any array ref
        //    }
            int ii = 1;
            varRef = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, ii);
            while(varRef != null) {
              sinter.PSE.variableAssignment thisVarAssign = (sinter.PSE.variableAssignment) varAssign.Clone();
              thisVarAssign.gPROMSPath = (String)varRef.Item1;
              varList.Add(thisVarAssign);
              ii++;
              varRef = (System.Tuple<String, bool>) this.GetValue(tree, TokenType.VariableRef, ii);
            }
        
          }
          return varList;
        }

        protected virtual object EvalForBlock(ParseTree tree, params object[] paramlist)
        {
            List<Object> exprlist = 	new List<Object>();
           int ii = 0;
           List<Object> currentVarExpr = (List<Object>) this.GetValue(tree, TokenType.VariableExpr, ii); 
           while(currentVarExpr != null) {
             foreach(Object thisObj in currentVarExpr) {
               if(thisObj is sinter.PSE.variableAssignment) {  //Declerations shouldn't even exist, we certainly can't do anything with them
                 sinter.PSE.variableAssignment thisAssign = (sinter.PSE.variableAssignment) thisObj;
                 if(thisAssign.isVec && thisAssign.gPROMSPath != "**invalid**") {  //Has to be a vector with an understandable path and id
                   exprlist.Add(thisAssign);
                 }
               }
             }
             ++ii;
             currentVarExpr = (List<Object>)  this.GetValue(tree, TokenType.VariableExpr, ii);
           }
           return exprlist;
        }

        protected virtual object EvalWithinBlock(ParseTree tree, params object[] paramlist)
        {
            List<Object> exprlist = 	new List<Object>();
           String id = (String) this.GetValue(tree, TokenType.IDENTIFIER, 0);
           int ii = 0;
           Object currentExpr = this.GetValue(tree, TokenType.Expr, ii); 
           while(currentExpr != null) {
             //Expr returns a list of variable declerations.  We need to add the within block
             //identifier to each of those, and return that new list.
             List<Object> withinExprs = (List<Object>) currentExpr;
             for(int jj = 0;  jj < withinExprs.Count; ++jj) {
         	Object thisExpr = withinExprs[jj];
               if(thisExpr is sinter.PSE.variableDecleration) {
                 sinter.PSE.variableDecleration thisDecl = (sinter.PSE.variableDecleration) withinExprs[jj++];
                 thisDecl.name = id + "." + thisDecl.name;
               } else if (thisExpr is sinter.PSE.variableAssignment) {
                 sinter.PSE.variableAssignment thisAssign = (sinter.PSE.variableAssignment) withinExprs[jj++];
                 if(thisAssign.gPROMSPath !=  "**invalid**") {  //Don't modify the sentinal value
                   thisAssign.gPROMSPath = id + "." + thisAssign.gPROMSPath;     
                 }
               }
             }
             exprlist.AddRange(withinExprs);
             ii++;
             currentExpr = this.GetValue(tree, TokenType.Expr, ii);
           }
           return exprlist;
        }

        protected virtual object EvalExpr(ParseTree tree, params object[] paramlist)
        {
            List<Object> varExpr = (List<Object>) this.GetValue(tree, TokenType.VariableExpr, 0); 
          if(varExpr != null) {
            List<Object> retList = new List<Object>();
            foreach(Object expr in varExpr) {
              //If it's a variableAssignement, we check to make sure it's not an array reference, if it's a decleration, it's good just return it.
              if(expr is sinter.PSE.variableAssignment) {
                 sinter.PSE.variableAssignment varAssign = (sinter.PSE.variableAssignment) expr;
                 if(!varAssign.isVec) {  //VariableExpr here is not a ForBlock, so we just ignore any array references.
                   retList.Add(expr);
                 }
              } else {
                 retList.Add(expr);         
              }
            } 
            //If VariableDef returns a list of variable declerations
            //so just return that list.
            return retList;
          }
          
          Object forBlock = this.GetValue(tree, TokenType.ForBlock, 0);
          if(forBlock != null) {
            return forBlock;
          } else {
            //Within Block also returns a list a varaible declerations, 
            //so just return that list.
            return this.GetValue(tree, TokenType.WithinBlock, 0);
          }
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            //Expr returns a list of variable declerations.  Need to merge those
           //all into a big flat list of all variable declerations.
           //(Start with the list from the first Expr rather than a new list)
           List<Object> exprlist = (List<Object>) this.GetValue(tree, TokenType.Expr, 0);
           int ii = 1;
           Object currentExpr = this.GetValue(tree, TokenType.Expr, ii); 
           while(currentExpr != null) {
             List<Object> exprs = (List<Object>) currentExpr;
             exprlist.AddRange(exprs);
             ii++;
             currentExpr = this.GetValue(tree, TokenType.Expr, ii);
           }
        
           if(exprlist == null) {
              exprlist = new List<Object>();
           }
           return exprlist;
        }

        protected virtual object EvalBadId(ParseTree tree, params object[] paramlist)
        {
            //OK, the identifier could be a selector (string) default.  We don't know yet as we don't know the decleration type yet.
          //But we really don't handle identifiers as part of defaults anyway, so the string type can tell us this arithmatic
          //expression is crap.
          if(this.GetValue(tree, TokenType.LPAREN, 0) == null) {
            return this.GetValue(tree, TokenType.IDENTIFIER, 0);
          } else {
            return "**invalid**";  //We can't do anything with array refs or function calls.  Sentinal value to show that it wasn't a useful ID.
          }
        }

        protected virtual object EvalAddExpr(ParseTree tree, params object[] paramlist)
        {
            Object multexpr1 = this.GetValue(tree, TokenType.MultExpr, 0);
               if(multexpr1 is String) {
                 return multexpr1;
               }
        	double Value = (double) multexpr1; //Must be a double if it's not a string
        
        	int i = 1;
               Object thismult = this.GetValue(tree, TokenType.MultExpr, i); 
        	while (thismult != null)
        	{
                      if(thismult is String) {
                        return thismult;
                      }
        		string sign = this.GetValue(tree, TokenType.PLUSMINUS, i-1).ToString();
        		if (sign == "+")
        			Value += (double) thismult; //Convert.ToDouble(this.GetValue(tree, TokenType.MultExpr, i++));
        		else 
        			Value -= (double) thismult; //Convert.ToDouble(this.GetValue(tree, TokenType.MultExpr, i++));
                      ++i;
                      thismult = this.GetValue(tree, TokenType.MultExpr, i);
        	}
        
        	return Value;
        }

        protected virtual object EvalMultExpr(ParseTree tree, params object[] paramlist)
        {
            Object atom1 = this.GetValue(tree, TokenType.ExponentExpr, 0);
               if(atom1 is String) {
                 return atom1;
               }
        	double Value = (double) atom1; //Must be a double if it's not a string
        	int i = 1;
               Object thisAtom = this.GetValue(tree, TokenType.ExponentExpr, i); 
        	while (thisAtom != null)
        	{
                      if(thisAtom is String) {
                        return thisAtom;
                      }
        		string sign = this.GetValue(tree, TokenType.MULTDIV, i-1).ToString();
        		if (sign == "*") {
        			Value *= (double) thisAtom; 
        		} else {
        			Value /= (double) thisAtom; 
                      }
                      ++i;
                      thisAtom = this.GetValue(tree, TokenType.ExponentExpr, i);
        	}
        	return Value;
        }

        protected virtual object EvalExponentExpr(ParseTree tree, params object[] paramlist)
        {
            Object atom1 = this.GetValue(tree, TokenType.Atom, 0);
               if(atom1 is String) {
                 return atom1;
               }
        	double Base = (double) atom1; //Must be a double if it's not a string
               Object Atom2 = this.GetValue(tree, TokenType.Atom, 1); 
               if(Atom2 == null) {  //No exponent case
                 return Base;
               }
               if(Atom2 is String) { //Exponent is calculateable case
                  return Atom2;  
               }
               double Exponent = (double) Atom2; //Convert.ToDouble(this.GetValue(tree, TokenType.Atom, i++));
        	
               return Math.Pow(Base,Exponent);
        }

        protected virtual object EvalAtom(ParseTree tree, params object[] paramlist)
        {
            Object number = this.GetValue(tree, TokenType.NUMBER, 0);
        	if (number != null) { 
                 return Convert.ToDouble(number);
               } 
               Object addexpr = this.GetValue(tree, TokenType.AddExpr, 0);
               if (addexpr != null) {
                 return addexpr;
               }
               return this.GetValue(tree, TokenType.BadId, 0);
        }


    }
    
    #endregion ParseTree
}
